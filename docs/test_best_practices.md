# パートナー要員管理システム テスト実装ベストプラクティス

## 1. テストの基本原則

### 1.1 テストピラミッド
- **ユニットテスト**: 最も数が多く、実行が速い
- **統合テスト**: ユニットテストより少なく、実行に時間がかかる
- **E2Eテスト**: 最も少なく、実行に最も時間がかかる

### 1.2 テストの独立性
- 各テストは他のテストに依存せず、独立して実行できるべき
- テスト間で状態を共有しない
- テストの実行順序に依存しない

### 1.3 テストの再現性
- テストは何度実行しても同じ結果を返すべき
- 外部依存（データベース、API、時間など）はモック化またはスタブ化する

### 1.4 テストの可読性
- テスト名は何をテストしているかを明確に示す
- Given-When-Then または Arrange-Act-Assert パターンを使用
- 複雑なセットアップはヘルパー関数に抽出

## 2. バックエンドテスト

### 2.1 ユニットテスト
- **対象**: 個々の関数、メソッド、クラス
- **ツール**: Jest
- **ベストプラクティス**:
  - 外部依存はモック化
  - 1テストにつき1つのアサーション
  - 境界値と異常系のテスト
  - プライベートメソッドは直接テストせず、パブリックAPIを通じてテスト

### 2.2 統合テスト
- **対象**: 複数のコンポーネントの連携
- **ツール**: Jest + NestJS Testing
- **ベストプラクティス**:
  - データベースはインメモリDBまたはテスト用DBを使用
  - トランザクションを使用してテスト後にロールバック
  - 外部APIはモック化
  - 実際のHTTPリクエスト/レスポンスをテスト

### 2.3 E2Eテスト
- **対象**: システム全体の動作
- **ツール**: Supertest + NestJS Testing
- **ベストプラクティス**:
  - テスト用のデータベースを使用
  - ユーザーストーリーに基づいたシナリオテスト
  - 認証を含むエンドツーエンドのフロー
  - テスト後のクリーンアップ

## 3. フロントエンドテスト

### 3.1 ユニットテスト
- **対象**: コンポーネント、カスタムフック、ユーティリティ関数
- **ツール**: Jest + React Testing Library
- **ベストプラクティス**:
  - コンポーネントの出力とユーザーインタラクションをテスト
  - 実装の詳細ではなく、動作をテスト
  - スナップショットテストは慎重に使用

### 3.2 統合テスト
- **対象**: 複数のコンポーネントの連携
- **ツール**: Jest + React Testing Library
- **ベストプラクティス**:
  - ユーザーの操作シーケンスをテスト
  - APIリクエストはモック化
  - 状態管理（Redux, Context）の連携をテスト

### 3.3 E2Eテスト
- **対象**: 実際のブラウザでのユーザー体験
- **ツール**: Cypress
- **ベストプラクティス**:
  - 重要なユーザーフローに焦点
  - テストデータの事前準備と後処理
  - ネットワークリクエストのスタブ化（必要に応じて）
  - 視覚的リグレッションテスト

## 4. テストカバレッジ

### 4.1 カバレッジ目標
- **ユニットテスト**: 80%以上のコードカバレッジ
- **統合テスト**: 主要なビジネスフローをカバー
- **E2Eテスト**: クリティカルなユーザーパスをカバー

### 4.2 カバレッジ測定
- Jest Coverage を使用してコードカバレッジを測定
- Cypress Dashboard でE2Eテストのカバレッジを追跡
- カバレッジレポートをCI/CDパイプラインに統合

## 5. テスト自動化

### 5.1 継続的インテグレーション
- プルリクエスト時に全テストを実行
- テスト失敗時はマージをブロック
- テスト実行時間の最適化（並列実行、テストの分割）

### 5.2 テスト環境
- 開発環境と同等のテスト環境
- テストデータの自動生成
- 環境変数による設定の切り替え

## 6. テストメンテナンス

### 6.1 フレイルテストの対応
- 不安定なテストの特定と修正
- 時間依存のテストは避ける
- セレクタの堅牢性を確保（ID > データ属性 > クラス > タグ）

### 6.2 テストコードのリファクタリング
- テストコードも製品コードと同様に定期的にリファクタリング
- 重複を排除し、共通のセットアップをヘルパー関数に抽出
- テストコードのコードレビュー

## 7. テスト駆動開発（TDD）

### 7.1 TDDサイクル
- Red: 失敗するテストを書く
- Green: テストが通るように最小限のコードを書く
- Refactor: コードをリファクタリングする（テストは通ったまま）

### 7.2 TDDの利点
- 設計の改善
- バグの早期発見
- リファクタリングの安全性
- ドキュメントとしての役割

## 8. テストデータ管理

### 8.1 テストデータの準備
- ファクトリーパターンを使用
- シード機能の活用
- テスト間のデータ分離

### 8.2 テストデータのクリーンアップ
- テスト前後のデータベースリセット
- トランザクションを使用したロールバック
- 一時ファイルの削除

## 9. モックとスタブ

### 9.1 適切なモック化
- 外部依存（データベース、API、時間など）
- 副作用のある操作
- 非決定的な動作

### 9.2 モックの落とし穴
- 過度なモック化は実際の動作との乖離を生む
- モックの更新忘れによるテストの信頼性低下
- 実装の詳細に依存したモック

## 10. 特殊なテスト

### 10.1 パフォーマンステスト
- 応答時間の測定
- スケーラビリティのテスト
- 負荷テスト

### 10.2 セキュリティテスト
- 認証・認可のテスト
- 入力バリデーション
- OWASP Top 10の脆弱性チェック

### 10.3 アクセシビリティテスト
- スクリーンリーダー対応
- キーボードナビゲーション
- コントラスト比
